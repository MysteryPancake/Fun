<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>UML to Java Converter</title>
		<meta name="description" content="Converts UML syntax to Java code.">
		<meta name="keywords" content="UMLet, UML, Java, Convert, Diagram, Code">
		<meta property="og:title" content="UML to Java Converter">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mysterypancake.github.io/Fun/html/umltojava">
		<meta property="og:site_name" content="UML to Java">
		<meta property="og:description" content="Converts UML syntax to Java code.">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>
		* {
			font-family: Verdana, Geneva, sans-serif;
		}

		html, body {
			height: 100%;
			margin: 0;
			overflow: hidden;
			padding: 0;
		}

		#copy {
			background-color: #DDDDDD;
			border-radius: 4px;
			color: black;
			cursor: pointer;
			font-size: medium;
			padding: 8px 16px;
		}

		#copy:hover {
			background-color: #EEEEEE;
		}

		#copy:active {
			background-color: #CCCCCC;
		}

		#sidecontrols {
			display: none;
			float: right;
			position: fixed;
			right: 8px;
			text-align: right;
			top: 8px;
		}

		#sidecontrols > div {
			padding-top: 8px;
		}

		#sameline, #samelinelabel, #javamode, #javamodelabel {
			color: white;
			cursor: pointer;
			user-select: none;
			-moz-user-select: none;
		}

		#umlbox {
			background-color: #DDDDDD;
		}

		#uml {
			background: none;
			border: none;
			box-sizing: border-box;
			font-size: large;
			height: 100%;
			margin: 0;
			outline: none;
			padding: 0;
			resize: none;
			width: 100%;
		}

		#code {
			background-color: hsl(60, 17%, 11%);
			color: white;
			font-size: medium;
			overflow: auto;
			white-space: pre-wrap;
		}

		#umlbox, #code {
			box-shadow: inset 0 0 4px black;
			box-sizing: border-box;
			display: inline-block;
			float: left;
			height: 100%;
			padding: 16px;
			width: 50%;
		}
		</style>
		<script>
		let umlElem;
		let codeElem;
		let buttonElem;
		let sameLineElem;
		let sideControlElem;
		let sameLine = false;
		let javaMode = false;

		function replaceSpaces(str) {
			return str.replace(/ /g, "_");
		}

		function sanitize(str) {
			return replaceSpaces(str.trim());
		}

		function sanitizeArg(arg) {
			arg.name = arg.name.trim();
			arg.type = arg.type.trim();
			if (arg.name && !arg.type) {
				const spaceIndex = arg.name.indexOf(" ");
				if (spaceIndex === -1) {
					arg.type = replaceSpaces(arg.name);
					arg.name = "";
					arg.placeholder = true;
					return;
				} else {
					arg.type = arg.name.slice(0, spaceIndex).trim();
					arg.name = arg.name.slice(spaceIndex).trim();
				}
			}
			arg.name = replaceSpaces(arg.name);
			arg.type = replaceSpaces(arg.type);
		}

		function cleanMess(str, startPos, endPos) {
			while (str.charAt(endPos) === "_") {
				str = str.slice(0, endPos) + str.slice(endPos + 1);
				endPos--;
			}
			while (str.charAt(startPos) === "_") {
				str = str.slice(0, startPos) + str.slice(startPos + 1);
			}
			return str.trim();
		}

		function parseLineUML(str) {
			const result = {
				name: "",
				type: "",
				value: "",
				scope: "",
				static: "",
				final: "",
				comment: "",
				commentOnly: false,
				args: []
			};
			if (str.toLowerCase().indexOf("{read only}") !== -1) {
				result.final = "final";
				str = str.replace(/{read only}/gi, "");
			}
			str = str.trim();
			const comment = str.indexOf("%%");
			if (comment !== -1) {
				result.comment = str.substr(comment + 2);
				str = str.slice(0, comment);
				if (str.length <= 0) {
					// Hacky
					result.type = undefined;
					result.commentOnly = true;
					return result;
				}
			}
			const last = str.lastIndexOf("_");
			if (str.charAt(0) === "_" && last !== -1) {
				result.static = "static";
				str = cleanMess(str, 0, last);
			}
			switch (str.charAt(0)) {
			case "+":
				result.scope = "public";
				str = str.slice(1);
				break;
			case "#":
				result.scope = "protected";
				str = str.slice(1);
				break;
			case "-":
				result.scope = "private";
				str = str.slice(1);
				break;
			default:
				result.scope = "public";
				break;
			}
			str = str.trim();
			if (!result.static) {
				const lastLine = str.lastIndexOf("_");
				if (str.charAt(0) === "_" && lastLine !== -1) {
					result.static = "static";
					str = cleanMess(str, 0, lastLine);
				}
			}
			const nextPart = str.search(/[:=(,]/);
			if (nextPart !== -1) {
				result.name = sanitize(str.substr(0, nextPart));
				str = str.slice(nextPart);
			} else {
				result.name = sanitize(str);
				return result;
			}
			str = str.trim();
			if (str.charAt(0) === "(") {
				str = str.slice(1);
				let nameMode = true;
				let currentArg = { name: "", type: "" };
				result.args.push(currentArg);
				while (str) {
					const char = str.charAt(0);
					if (char === ")") {
						str = str.slice(1);
						break;
					}
					switch (char) {
					case ":":
						nameMode = false;
						break;
					case ",":
						sanitizeArg(currentArg);
						currentArg = { name: "", type: "" };
						result.args.push(currentArg);
						if (!nameMode) {
							nameMode = true;
						}
						break;
					default:
						if (nameMode) {
							currentArg.name += char;
						} else {
							currentArg.type += char;
						}
						break;
					}
					str = str.slice(1);
				}
				sanitizeArg(currentArg);
			}
			str = str.trim();
			if (str.charAt(0) === ":") {
				str = str.slice(1);
				const nextValue = str.indexOf("=");
				if (nextValue !== -1) {
					result.type = sanitize(str.substr(0, nextValue));
					str = str.slice(nextValue);
				} else {
					result.type = sanitize(str);
					return result;
				}
			}
			str = str.trim();
			if (str.charAt(0) === "=") {
				result.value = str.slice(1).trim();
			}
			return result;
		}

		function roughlyMatches(paramName, targetName, classLowered) {
			const paramLowered = paramName.toLowerCase();
			return (paramLowered === targetName) || (classLowered + paramLowered === targetName);
		}

		function capitalizeFirst(str) {
			return str.charAt(0).toUpperCase() + str.slice(1);
		}

		function associateArgs(varParts, parameters, className) {
			varParts.method = "";
			const classLowered = className.toLowerCase();
			const lowered = varParts.name.toLowerCase();
			const setter = lowered.startsWith("set");
			const firstArg = varParts.args[0];
			if (lowered.startsWith("get") && !varParts.value) {
				// Getter method
				const targetName = lowered.slice(3);
				for (let i = 0; i < parameters.length; i++) {
					if (roughlyMatches(parameters[i].name, targetName, classLowered) && parameters[i].type === varParts.type) {
						varParts.method += "\n\t\treturn this." + parameters[i].name + ";";
					}
				}
			} else if (setter || lowered.startsWith("change") && firstArg) {
				// Setter method
				const targetName = lowered.slice(setter ? 3 : 6);
				for (let i = 0; i < parameters.length; i++) {
					if (roughlyMatches(parameters[i].name, targetName, classLowered) && parameters[i].type === firstArg.type) {
						// Fill in placeholders
						if (firstArg.placeholder) {
							firstArg.name = "new" + capitalizeFirst(parameters[i].name);
							firstArg.placeholder = false;
						}
						varParts.method += "\n\t\tthis." + parameters[i].name + " = " + firstArg.name + ";";
					}
				}
			} else if (varParts.name === className) {
				// Class constructor
				const usedArgs = [];
				const usedParams = [];
				// First pass: matching variable names only
				for (let i = 0; i < varParts.args.length; i++) {
					const argument = varParts.args[i];
					const loweredName = argument.name.toLowerCase();
					for (let j = 0; j < parameters.length; j++) {
						if (parameters[j].type !== argument.type || usedParams.indexOf(j) !== -1) continue;
						if (roughlyMatches(parameters[j].name, loweredName, classLowered)) {
							usedArgs[i] = "\n\t\tthis." + parameters[j].name + " = " + argument.name + ";";
							usedParams.push(j);
							break;
						}
					}
					
				}
				// Second pass: ignoring variable names
				for (let j = 0; j < varParts.args.length; j++) {
					if (usedArgs[j] !== undefined) continue;
					const argument = varParts.args[j];
					for (let k = 0; k < parameters.length; k++) {
						if (parameters[k].type !== argument.type || usedParams.indexOf(k) !== -1) continue;
						// Fill in placeholders
						if (argument.placeholder) {
							argument.name = parameters[k].name;
							argument.placeholder = false;
						}
						usedArgs[j] = "\n\t\tthis." + parameters[k].name + " = " + argument.name + ";";
						usedParams.push(k);
						break;
					}
				}
				// Third pass: add results in order of argument index
				for (let l = 0; l < usedArgs.length; l++) {
					if (usedArgs[l] === undefined) continue;
					varParts.method += usedArgs[l];
				}
			}
			if (varParts.value) {
				varParts.method += "\n\t\treturn " + varParts.value + ";";
			}
			if (!varParts.method) {
				varParts.method += "\n\t\t// Type stuff here";
			}
			// Generate arguments for display
			let joined = "";
			let charIndex = 0;
			for (let i = 0; i < varParts.args.length; i++) {
				if (i > 0) {
					joined += ", ";
				}
				const argument = varParts.args[i];
				if (argument.placeholder) {
					argument.name = String.fromCharCode(97 + (charIndex + 23) % 26);
					if (charIndex >= 26) {
						argument.name += (1 + Math.floor(charIndex / 26));
					}
					charIndex++;
				}
				joined += (argument.type + " " + argument.name).trim();
			}
			return joined;
		}

		function formatVar(varParts, parameters, className) {
			let joined = "";
			if (varParts.comment) {
				joined += "//" + varParts.comment;
				if (!varParts.commentOnly) {
					joined += "\n\t";
				}
			}
			joined += (varParts.scope + " " + (varParts.static + " " + varParts.final).trim()).trim();
			if (varParts.type) {
				joined += " " + varParts.type;
			} else if (varParts.name !== className && !varParts.commentOnly) {
				// Add void return type to avoid errors
				joined += " void";
			}
			if (varParts.name) {
				joined += " " + varParts.name;
			}
			if (varParts.args.length) {
				joined += "(";
				joined += associateArgs(varParts, parameters, className);
				joined += ")";
			} else {
				if (varParts.value) {
					joined += " = " + varParts.value;
				}
			}
			if (varParts.args.length) {
				joined += sameLine ? " {" : "\n\t{";
				joined += varParts.method;
				joined += "\n\t}";
			} else if (!varParts.commentOnly) {
				joined += ";";
			}
			return joined;
		}

		function formatFromUML(parameters, methods, className) {
			let result = "";
			for (let i = 0; i < parameters.length; i++) {
				result += "\t" + formatVar(parameters[i]) + "\n";
			}
			for (let j = 0; j < methods.length; j++) {
				if (result) {
					result += "\n"
				}
				result += "\t" + formatVar(methods[j], parameters, className) + "\n";
			}
			return result;
		}

		function copyCode() {
			var range = document.createRange();
			range.selectNode(codeElem);
			window.getSelection().removeAllRanges();
			window.getSelection().addRange(range);
			document.execCommand("copy");
			buttonElem.value = "Copied";
			umlElem.focus();
		}

		function toggleSameLine(elem) {
			sameLine = elem.checked;
			update();
		}

		function toggleJavaMode(elem) {
			javaMode = elem.checked;
			sameLineElem.style.display = javaMode ? "none" : "block";
			update();
		}

		function updateUML() {
			let className = "";
			const lines = umlElem.value.split("\n");
			let result = "";
			const parameters = [];
			const methods = [];
			while (lines.length > 0) {
				const line = lines.shift().trim();
				if (!line || line === "--") continue;
				if (className) {
					const parts = parseLineUML(line);
					if (parts) {
						if (parts.args.length) {
							methods.push(parts);
						} else {
							parameters.push(parts);
						}
					}
				} else {
					className = replaceSpaces(line);
					result += "class " + className + (sameLine ? " {\n\n" : "\n{\n");
				}
			}
			if (result) {
				result += formatFromUML(parameters, methods, className);
				result += "}";
			}
			codeElem.textContent = result;
			
		}

		function parseLineJava(str) {
			const result = {
				name: "",
				type: "",
				value: "",
				scope: "",
				static: false,
				final: false,
				args: []
			};
			if (str.startsWith("public")) {
				result.scope = "+";
				str = str.slice(6);
			} else if (str.startsWith("protected")) {
				result.scope = "#";
				str = str.slice(9);
			} else if (str.startsWith("private")) {
				result.scope = "-";
				str = str.slice(7);
			}
			str = str.trim();
			if (str.startsWith("static")) {
				result.static = true;
				str = str.slice(6);
			} else if (str.startsWith("final")) {
				result.final = true;
				str = str.slice(5);
			}
			str = str.trim();
			// This is dumb but repeat again just in case
			if (str.startsWith("static")) {
				result.static = true;
				str = str.slice(6);
			} else if (str.startsWith("final")) {
				result.final = true;
				str = str.slice(5);
			}
			str = str.trim();
			const namePart = str.search(/[=(, ;{}]/);
			if (namePart !== -1) {
				result.type = str.substr(0, namePart);
				str = str.slice(namePart);
			} else {
				result.type = str.trim();
				return result;
			}
			str = str.trim();
			const nextPart = str.search(/[=(, ;{}]/);
			if (nextPart !== -1) {
				result.name = sanitize(str.substr(0, nextPart));
				str = str.slice(nextPart);
			} else {
				result.name = sanitize(str.trim());
				return result;
			}
			str = str.trim();
			if (str.charAt(0) === "(") {
				str = str.slice(1);
				let nameMode = false;
				let currentArg = { name: "", type: "" };
				result.args.push(currentArg);
				while (str) {
					const char = str.charAt(0);
					if (char === ")") {
						str = str.slice(1);
						break;
					}
					switch (char) {
					case " ":
						nameMode = true;
						break;
					case ",":
						currentArg.name = sanitize(currentArg.name);
						currentArg.type = sanitize(currentArg.type);
						currentArg = { name: "", type: "" };
						result.args.push(currentArg);
						if (nameMode) {
							nameMode = false;
						}
						break;
					default:
						if (nameMode) {
							currentArg.name += char;
						} else {
							currentArg.type += char;
						}
						break;
					}
					str = str.slice(1);
				}
				currentArg.name = sanitize(currentArg.name);
				currentArg.type = sanitize(currentArg.type);
			}
			str = str.trim();
			if (str.charAt(0) === "=") {
				str = str.slice(1).trim();
				const nextPart = str.search(/[( ;{}]/);
				if (nextPart !== -1) {
					result.value = str.substr(0, nextPart);
				} else {
					result.value = str;
				}
			}
			return result;
		}

		function formatStuff(parts) {
			let result = "";
			if (parts.static) {
				result += "__";
			}
			result += parts.scope;
			if (parts.name) {
				result += parts.name;
			}
			if (parts.args.length) {
				result += "(";
				for (let i = 0; i < parts.args.length; i++) {
					if (i > 0) {
						result += ", ";
					}
					const argument = parts.args[i];
					if (argument.name) {
						result += argument.name;
					}
					if (argument.name && argument.type) {
						result += ": ";
					}
					if (argument.type) {
						result += argument.type;
					}
				}
				result += ")";
			}
			if (parts.name && parts.type) {
				result += ": ";
			}
			if (parts.type) {
				result += parts.type;
			}
			if (parts.value) {
				result += " = " + parts.value;
			}
			if (parts.final) {
				result += " {read only}";
			}
			if (parts.static) {
				result += "__";
			}
			result += "\n";
			return result;
		}

		function formatFromJava(classes) {
			let result = "";
			for (let i = 0; i < classes.length; i++) {
				const thisClass = classes[i];
				result += thisClass.name + "\n--\n";
				for (let j = 0; j < thisClass.parameters.length; j++) {
					result += formatStuff(thisClass.parameters[j]);
				}
				if (thisClass.parameters.length && thisClass.methods.length) {
					result += "--\n";
				}
				for (let k = 0; k < thisClass.methods.length; k++) {
					result += formatStuff(thisClass.methods[k]);
				}
				result += "\n";
			}
			return result;
		}

		function updateJava() {
			const lines = umlElem.value.split("\n");
			const classes = [];
			let currentClass
			while (lines.length > 0) {
				const line = lines.shift().trim();
				if (!line) continue;
				const parts = parseLineJava(line);
				if (parts) {
					if (parts.type === "class") {
						currentClass = {
							name: parts.name,
							methods: [],
							parameters: []
						};
						classes.push(currentClass);
					} else if (currentClass) {
						if (parts.args.length) {
							currentClass.methods.push(parts);
						} else {
							currentClass.parameters.push(parts);
						}
					}
				}
			}
			codeElem.textContent = formatFromJava(classes);
		}

		function update() {
			if (javaMode) {
				updateJava();
			} else {
				updateUML();
			}
			sideControlElem.style.display = (codeElem.textContent || javaMode) ? "block" : "none";
			buttonElem.value = "Copy";
		};

		function setup() {
			umlElem = document.getElementById("uml");
			codeElem = document.getElementById("code");
			buttonElem = document.getElementById("copy");
			sameLineElem = document.getElementById("samelinebox");
			sideControlElem = document.getElementById("sidecontrols");
		}
		</script>
	</head>
	<body onload="setup();">
		<div id="umlbox">
			<textarea id="uml" autocomplete="off" spellcheck="false" oninput="update();" autofocus></textarea>
		</div>
		<div id="sidecontrols">
			<input type="button" id="copy" value="Copy" onclick="copyCode();">
			<div id="samelinebox">
				<input type="checkbox" id="sameline" onclick="toggleSameLine(this);">
				<label for="sameline" id="samelinelabel">Same line brackets</label>
			</div>
			<!--<div>
				<input type="checkbox" id="javamode" onclick="toggleJavaMode(this);">
				<label for="javamode" id="javamodelabel">Java to UML</label>
			</div>-->
		</div>
		<div id="code"></div>
	</body>
</html>
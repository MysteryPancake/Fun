<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Fourier Synth</title>
		<meta name="description" content="Synth using concepts from the Fourier Transform.">
		<meta name="keywords" content="Fourier, Synthesizer, Synth">
		<meta property="og:title" content="Fourier Synth">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mysterypancake.github.io/Fun/html/fouriersynth">
		<meta property="og:site_name" content="Fourier Synth">
		<meta property="og:description" content="Synth using concepts from the Fourier Transform.">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>
		* {
			font-family: "Trebuchet MS", Helvetica, sans-serif;
		}

		#left {
			float: left;
			margin-right: 8px;
		}

		#circleTable {
			display: none;
		}

		canvas, table {
			margin-top: 8px;
		}

		table, th, td {
			border: 1px solid black;
			border-collapse: collapse;
		}

		table tr:first-child {
			font-weight: bold;
		}

		th, td {
			padding: 8px;
		}
		</style>
		<script>
		let canvas;
		let canvasCtx;
		let audioCtx;
		let fundamental = 440;
		let lockView = false;
		let zoom = 400;
		let circleTable;
		const circles = [];
		const trail = [];
		const PI2 = Math.PI * 2;
		const requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) { return window.setTimeout(e, 1000 / 60); };

		function setup() {
			circleTable = document.getElementById("circleTable");
			canvas = document.getElementById("canvas");
			canvasCtx = canvas.getContext("2d");
			requestFrame(draw);
		}

		function createContext() {
			if (audioCtx) return;
			audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			const processor = audioCtx.createScriptProcessor(2048, 1, 1);
			let phase = 0;
			processor.onaudioprocess = function(e) {
				const output = e.outputBuffer.getChannelData(0);
				for (let i = 0; i < output.length; i++) {
					let yPos = 0;
					for (let j = 0; j < circles.length; j++) {
						const circle = circles[j];
						const angle = phase * fundamental * circle.speed;
						yPos += Math.cos(angle) * circle.radius;
					}
					output[i] = yPos;
					// Not sure if the modulo is correct, but it prevents overflow
					phase = (phase + Math.PI / audioCtx.sampleRate) % PI2;
				}
			};
			processor.connect(audioCtx.destination);
		}

		function addCircle() {
			createContext();
			const speed = Math.floor(circles.length / 2) + 1;
			const circle = {
				radius: 0.1,
				speed: circles.length % 2 == 0 ? speed : -speed
			};
			circles.push(circle);
			updateTable(circle);
		}

		function addHarmonic() {
			addCircle();
			addCircle();
		}

		function updateTable(circle) {
			circleTable.style.display = "inline-table";
			const row = circleTable.insertRow(-1);
			// Add radius controller to table
			const radiusCell = row.insertCell(-1);
			const radiusInput = document.createElement("input");
			radiusInput.type = "number";
			radiusInput.step = "0.1";
			radiusInput.value = circle.radius;
			radiusInput.addEventListener("input", function(e) {
				circle.radius = parseFloat(e.target.value);
			});
			radiusCell.appendChild(radiusInput);
			// Add speed controller to table
			const speedCell = row.insertCell(-1);
			const speedInput = document.createElement("input");
			speedInput.type = "number";
			speedInput.step = "0.1";
			speedInput.value = circle.speed;
			speedInput.addEventListener("input", function(e) {
				circle.speed = parseFloat(e.target.value);
			});
			speedCell.appendChild(speedInput);
			// Add delete button
			const deleteCell = row.insertCell(-1);
			const deleteButton = document.createElement("input");
			deleteButton.type = "button";
			deleteButton.value = "Remove";
			deleteButton.addEventListener("click", function(e) {
				// Remove displayed row
				circleTable.deleteRow(row.rowIndex);
				// Remove from circles array
				const index = circles.indexOf(circle);
				if (index !== -1) {
					circles.splice(index, 1);
				}
				// Hide table if required
				if (circles.length <= 0) {
					circleTable.style.display = "none";
				}
			});
			deleteCell.appendChild(deleteButton);
		}

		function degreesToRadians(degrees) {
			return degrees * Math.PI / 180;
		}

		function draw() {
			canvasCtx.fillStyle = "black";
			canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
			if (audioCtx && circles.length) {
				// Draw circles and lines
				let xPos = canvas.width / 2;
				let yPos = canvas.height / 2;
				for (let i = 0; i < circles.length; i++) {
					const circle = circles[i];
					// This angle is much slower than reality
					const angle = degreesToRadians(audioCtx.currentTime * fundamental * circle.speed);
					const radiusPixels = circle.radius * zoom;
					// Draw circle
					canvasCtx.strokeStyle = "gray";
					canvasCtx.lineWidth = 2;
					canvasCtx.beginPath();
					canvasCtx.arc(xPos, yPos, radiusPixels, 0, PI2);
					canvasCtx.stroke();
					// Draw line
					canvasCtx.strokeStyle = "white";
					canvasCtx.lineWidth = 4;
					canvasCtx.beginPath();
					canvasCtx.moveTo(xPos, yPos);
					// Based on the circle example from https://wiki.facepunch.com/gmod/surface.DrawPoly
					xPos += Math.sin(angle) * radiusPixels;
					// Subtracting because the coordinate system is different compared to audio
					yPos -= Math.cos(angle) * radiusPixels;
					canvasCtx.lineTo(xPos, yPos);
					canvasCtx.stroke();
				}
				// Draw trail (lazily)
				canvasCtx.strokeStyle = "red";
				canvasCtx.lineWidth = 4;
				canvasCtx.beginPath();
				const xCoord = lockView ? canvas.width / 2 : xPos;
				for (let j = 0; j < trail.length; j++) {
					canvasCtx.lineTo(xCoord - (trail.length - j), trail[j]);
				}
				canvasCtx.stroke();
				// The trail acts as a lazy circular buffer
				if (trail.length > canvas.width) {
					trail.shift();
				}
				trail.push(yPos);
			}
			requestFrame(draw);
		}

		function changeFundamental(elem) {
			fundamental = parseFloat(elem.value);
		}

		function lockX(elem) {
			lockView = elem.checked;
		}

		function changeZoom(elem) {
			zoom = parseFloat(elem.value);
		}
		</script>
	</head>
	<body onload="setup();">
		<h1>Fourier Synth</h1>
		<div id="left">
			<div>
				<label for="frequency">Fundamental Frequency (Hz)</label>
				<input id="frequency" type="number" value="440" oninput="changeFundamental(this);">
			</div>
			<canvas id="canvas" width="400" height="400"></canvas>
			<div>
				<label for="zoom">Zoom</label>
				<input id="zoom" type="range" min="1" max="2000" value="400" oninput="changeZoom(this);">
				<input id="lockX" type="checkbox" onchange="lockX(this);">
				<label for="lockX">Lock X axis</label>
			</div>
		</div>
		<div>
			<div>
				<input type="button" value="Add circle" onclick="addCircle();">
				<input type="button" value="Add 2 circles (1 harmonic)" onclick="addHarmonic();">
			</div>
			<table id="circleTable">
				<tr>
					<th>Circle Radius (Volume)</th>
					<th>Relative Circle Speed (Frequency)</th>
				</tr>
			</table>
		</div>
	</body>
</html>